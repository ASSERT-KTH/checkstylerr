/* OWLFunctionalSyntaxParser.java */
/* Generated By:JavaCC: Do not edit this line. OWLFunctionalSyntaxParser.java */
package org.semanticweb.owlapi.functional.parser;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.semanticweb.owlapi.formats.FunctionalSyntaxDocumentFormat;
import org.semanticweb.owlapi.io.OWLParserException;
import org.semanticweb.owlapi.model.AddImport;
import org.semanticweb.owlapi.model.AddOntologyAnnotation;
import org.semanticweb.owlapi.model.IRI;
import org.semanticweb.owlapi.model.OWLAnnotation;
import org.semanticweb.owlapi.model.OWLAnnotationAssertionAxiom;
import org.semanticweb.owlapi.model.OWLAnnotationAxiom;
import org.semanticweb.owlapi.model.OWLAnnotationProperty;
import org.semanticweb.owlapi.model.OWLAnnotationPropertyDomainAxiom;
import org.semanticweb.owlapi.model.OWLAnnotationPropertyRangeAxiom;
import org.semanticweb.owlapi.model.OWLAnnotationSubject;
import org.semanticweb.owlapi.model.OWLAnnotationValue;
import org.semanticweb.owlapi.model.OWLAnonymousIndividual;
import org.semanticweb.owlapi.model.OWLAxiom;
import org.semanticweb.owlapi.model.OWLClass;
import org.semanticweb.owlapi.model.OWLClassAxiom;
import org.semanticweb.owlapi.model.OWLClassExpression;
import org.semanticweb.owlapi.model.OWLDataFactory;
import org.semanticweb.owlapi.model.OWLDataProperty;
import org.semanticweb.owlapi.model.OWLDataPropertyExpression;
import org.semanticweb.owlapi.model.OWLDataRange;
import org.semanticweb.owlapi.model.OWLDatatype;
import org.semanticweb.owlapi.model.OWLDatatypeDefinitionAxiom;
import org.semanticweb.owlapi.model.OWLEntity;
import org.semanticweb.owlapi.model.OWLFacetRestriction;
import org.semanticweb.owlapi.model.OWLHasKeyAxiom;
import org.semanticweb.owlapi.model.OWLImportsDeclaration;
import org.semanticweb.owlapi.model.OWLIndividual;
import org.semanticweb.owlapi.model.OWLIndividualAxiom;
import org.semanticweb.owlapi.model.OWLLiteral;
import org.semanticweb.owlapi.model.OWLNamedIndividual;
import org.semanticweb.owlapi.model.OWLObjectProperty;
import org.semanticweb.owlapi.model.OWLObjectPropertyExpression;
import org.semanticweb.owlapi.model.OWLOntology;
import org.semanticweb.owlapi.model.OWLOntologyChange;
import org.semanticweb.owlapi.model.OWLOntologyID;
import org.semanticweb.owlapi.model.OWLOntologyLoaderConfiguration;
import org.semanticweb.owlapi.model.OWLOntologyManager;
import org.semanticweb.owlapi.model.OWLPropertyAxiom;
import org.semanticweb.owlapi.model.OWLPropertyExpression;
import org.semanticweb.owlapi.model.OWLRuntimeException;
import org.semanticweb.owlapi.model.OWLSubAnnotationPropertyOfAxiom;
import org.semanticweb.owlapi.model.PrefixManager;
import org.semanticweb.owlapi.model.SWRLAtom;
import org.semanticweb.owlapi.model.SWRLBuiltInAtom;
import org.semanticweb.owlapi.model.SWRLClassAtom;
import org.semanticweb.owlapi.model.SWRLDArgument;
import org.semanticweb.owlapi.model.SWRLDataPropertyAtom;
import org.semanticweb.owlapi.model.SWRLDataRangeAtom;
import org.semanticweb.owlapi.model.SWRLDifferentIndividualsAtom;
import org.semanticweb.owlapi.model.SWRLIArgument;
import org.semanticweb.owlapi.model.SWRLObjectPropertyAtom;
import org.semanticweb.owlapi.model.SWRLRule;
import org.semanticweb.owlapi.model.SWRLSameIndividualAtom;
import org.semanticweb.owlapi.model.SetOntologyID;
import org.semanticweb.owlapi.model.UnloadableImportException;
import org.semanticweb.owlapi.util.EscapeUtils;
import org.semanticweb.owlapi.util.RemappingIndividualProvider;
import org.semanticweb.owlapi.vocab.Namespaces;
import org.semanticweb.owlapi.vocab.OWLFacet;

@SuppressWarnings("all")
public class OWLFunctionalSyntaxParser implements OWLFunctionalSyntaxParserConstants {

    private OWLOntologyManager man;
    private OWLOntologyLoaderConfiguration configuration;
    private OWLOntology ontology;
    private OWLDataFactory df;
    private Map<String, IRI> string2IRI;
    private Map<String, String> prefixMap;
    private IRI ontologyIRI;
    private boolean ignoreAnnotationsAndDeclarations = false;
    private Set<OWLAnnotation> currentAnnotations;
    protected RemappingIndividualProvider anonProvider;

    public void setUp(OWLOntology ontology, OWLOntologyLoaderConfiguration configuration) {
        this.man = ontology.getOWLOntologyManager();
        this.ontology = ontology;
        this.configuration = configuration;
        this.df = man.getOWLDataFactory();
        anonProvider = new RemappingIndividualProvider(man.getOntologyConfigurator(), df);
        this.currentAnnotations = new HashSet<OWLAnnotation>();
        if (prefixMap == null) {
            prefixMap = new HashMap<String, String>();
            prefixMap.put("owl:", Namespaces.OWL.toString());
            prefixMap.put("rdf:", Namespaces.RDF.toString());
            prefixMap.put("rdfs:", Namespaces.RDFS.toString());
            prefixMap.put("xml:", Namespaces.XML.toString());
            prefixMap.put("xsd:", Namespaces.XSD.toString());
        }
        string2IRI = new HashMap<String, IRI>();
    }

    public IRI getIRI(String s) {
        IRI iri = string2IRI.get(s);
        if (iri == null) {
            if (s.charAt(0) == '<') {
                iri = IRI.create(s.substring(1, s.length() - 1));
            } else {
                int colonIndex = s.indexOf(':');
                String prefixName = s.substring(0, colonIndex + 1);
                String prefix = prefixMap.get(prefixName);
                if (prefix == null) {
                    throw new OWLRuntimeException("Undefined prefix name: " + prefixName);
                }
                String fullIRIString = prefix + s.substring(colonIndex + 1);
                iri = IRI.create(fullIRIString);
            }
            string2IRI.put(s, iri);
        }
        return iri;
    }

    public void setIgnoreAnnotationsAndDeclarations(boolean b) {
        ignoreAnnotationsAndDeclarations = b;
    }

    protected void applyChange(OWLOntologyChange chg) {
        man.applyChange(chg);
    }

    protected void addAxiom(OWLAxiom ax) {
        if (!(ax instanceof OWLAnnotationAxiom) || configuration.isLoadAnnotationAxioms()) {
            ontology.addAxiom(ax);
        }
    }

    public void setPrefixes(PrefixManager nsm) {
        if (prefixMap == null) {
            prefixMap = new HashMap<String, String>();
        }
        prefixMap.putAll(nsm.getPrefixName2PrefixMap());
    }

    final public FunctionalSyntaxDocumentFormat parse()
        throws ParseException, OWLParserException, UnloadableImportException {
        label_1:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case PREFIX: {
                    ;
                    break;
                }
                default:
                    jj_la1[0] = jj_gen;
                    break label_1;
            }
            Prefix();
        }
        Ontology();
        jj_consume_token(0);
        FunctionalSyntaxDocumentFormat format = new FunctionalSyntaxDocumentFormat();
        for (String pn : prefixMap.keySet()) {
            format.setPrefix(pn, prefixMap.get(pn));
        }
        return format;
    }

    final public void Ontology()
        throws ParseException, OWLParserException, UnloadableImportException {
        OWLAnnotation anno;
        OWLAxiom ax;
        OWLImportsDeclaration decl;
        int count = 0;
        IRI versionIRI = null;
        jj_consume_token(ONTOLOGY);
        jj_consume_token(OPENPAR);
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case FULLIRI:
            case PNAME_LN: {
                ontologyIRI = IRI();
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case FULLIRI:
                    case PNAME_LN: {
                        versionIRI = IRI();
                        break;
                    }
                    default:
                        jj_la1[1] = jj_gen;
                        ;
                }
                break;
            }
            default:
                jj_la1[2] = jj_gen;
                ;
        }
        OWLOntologyID id = new OWLOntologyID(ontologyIRI, versionIRI);
        applyChange(new SetOntologyID(ontology, id));
        label_2:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case IMPORT:
                case ANNOTATION: {
                    ;
                    break;
                }
                default:
                    jj_la1[3] = jj_gen;
                    break label_2;
            }
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case IMPORT: {
                    decl = ImportsDeclaration();
                    applyChange(new AddImport(ontology, decl));
                    man.makeLoadImportRequest(decl, configuration);
                    break;
                }
                case ANNOTATION: {
                    anno = Annotation();
                    applyChange(new AddOntologyAnnotation(ontology, anno));
                    currentAnnotations.clear();
                    break;
                }
                default:
                    jj_la1[4] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
        label_3:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case SUBCLASSOF:
                case EQUIVALENTCLASSES:
                case DISJOINTCLASSES:
                case DISJOINTUNION:
                case ANNOTATIONASSERTION:
                case SUBANNOTATIONPROPERTYOF:
                case ANNOTATIONPROPERTYDOMAIN:
                case ANNOTATIONPROPERTYRANGE:
                case HASKEY:
                case DECLARATION:
                case INVERSEOBJECTPROPERTIES:
                case DATATYPEDEFINITION:
                case SUBOBJECTPROPERTYOF:
                case EQUIVALENTOBJECTPROPERTIES:
                case DISJOINTOBJECTPROPERTIES:
                case OBJECTPROPERTYDOMAIN:
                case OBJECTPROPERTYRANGE:
                case FUNCTIONALOBJECTPROPERTY:
                case INVERSEFUNCTIONALOBJECTPROPERTY:
                case REFLEXIVEOBJECTPROPERTY:
                case IRREFLEXIVEOBJECTPROPERTY:
                case SYMMETRICOBJECTPROPERTY:
                case ASYMMETRICOBJECTPROPERTY:
                case TRANSITIVEOBJECTPROPERTY:
                case SUBDATAPROPERTYOF:
                case EQUIVALENTDATAPROPERTIES:
                case DISJOINTDATAPROPERTIES:
                case DATAPROPERTYDOMAIN:
                case DATAPROPERTYRANGE:
                case FUNCTIONALDATAPROPERTY:
                case SAMEINDIVIDUAL:
                case DIFFERENTINDIVIDUALS:
                case CLASSASSERTION:
                case OBJECTPROPERTYASSERTION:
                case NEGATIVEOBJECTPROPERTYASSERTION:
                case DATAPROPERTYASSERTION:
                case NEGATIVEDATAPROPERTYASSERTION:
                case DLSAFERULE: {
                    ;
                    break;
                }
                default:
                    jj_la1[5] = jj_gen;
                    break label_3;
            }
            ax = Axiom();
            addAxiom(ax);
            currentAnnotations.clear();
        }
        jj_consume_token(CLOSEPAR);
    }

    final public void Prefix() throws ParseException {
        String prefixName;
        IRI iri;
        jj_consume_token(PREFIX);
        jj_consume_token(OPENPAR);
        prefixName = PrefixName();
        jj_consume_token(EQUALS);
        iri = FullIRI();
        jj_consume_token(CLOSEPAR);
        prefixMap.put(prefixName, iri.toString());
    }

    final public IRI IRI() throws ParseException {
        IRI iri;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case FULLIRI: {
                iri = FullIRI();
                break;
            }
            case PNAME_LN: {
                iri = AbbreviatedIRI();
                break;
            }
            default:
                jj_la1[6] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return iri;
    }

    final public IRI FullIRI() throws ParseException {
        Token t;
        t = jj_consume_token(FULLIRI);
        return getIRI(t.image);
    }

    final public IRI AbbreviatedIRI() throws ParseException {
        Token t;
        t = jj_consume_token(PNAME_LN);
        return getIRI(t.image);
    }

    final public String PrefixName() throws ParseException {
        Token t;
        t = jj_consume_token(PNAME_NS);
        return t.image;
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Class Descriptions
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
    final public OWLClassExpression ClassExpression() throws ParseException {
        OWLClassExpression desc;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case FULLIRI:
            case PNAME_LN: {
                desc = ClassIRI();
                break;
            }
            case OBJECTUNIONOF: {
                desc = ObjectUnionOf();
                break;
            }
            case OBJECTINTERSECTIONOF: {
                desc = ObjectIntersectionOf();
                break;
            }
            case OBJECTCOMPLEMENTOF: {
                desc = ObjectComplementOf();
                break;
            }
            case OBJECTONEOF: {
                desc = ObjectOneOf();
                break;
            }
            case OBJECTSOMEVALUESFROM: {
                desc = ObjectSomeValuesFrom();
                break;
            }
            case OBJECTALLVALUESFROM: {
                desc = ObjectAllValuesFrom();
                break;
            }
            case OBJECTHASVALUE: {
                desc = ObjectHasValue();
                break;
            }
            case OBJECTHASSELF: {
                desc = ObjectSelf();
                break;
            }
            case OBJECTMINCARDINALITY: {
                desc = ObjectMinCardinality();
                break;
            }
            case OBJECTEXACTCARDINALITY: {
                desc = ObjectExactCardinality();
                break;
            }
            case OBJECTMAXCARDINALITY: {
                desc = ObjectMaxCardinality();
                break;
            }
            case DATASOMEVALUESFROM: {
                desc = DataSomeValuesFrom();
                break;
            }
            case DATAALLVALUESFROM: {
                desc = DataAllValuesFrom();
                break;
            }
            case DATAHASVALUE: {
                desc = DataHasValue();
                break;
            }
            case DATAMINCARDINALITY: {
                desc = DataMinCardinality();
                break;
            }
            case DATAEXACTCARDINALITY: {
                desc = DataExactCardinality();
                break;
            }
            case DATAMAXCARDINALITY: {
                desc = DataMaxCardinality();
                break;
            }
            default:
                jj_la1[7] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return desc;
    }

    final public OWLClass ClassIRI() throws ParseException {
        IRI iri;
        iri = IRI();
        return df.getOWLClass(iri);
    }

    final public Set<OWLClassExpression> ClassExpressionSet() throws ParseException {
        Set<OWLClassExpression> classExpressions = new HashSet<OWLClassExpression>();
        OWLClassExpression desc;
        desc = ClassExpression();
        classExpressions.add(desc);
        desc = ClassExpression();
        classExpressions.add(desc);
        label_4:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case OBJECTONEOF:
                case OBJECTUNIONOF:
                case OBJECTHASVALUE:
                case OBJECTINTERSECTIONOF:
                case OBJECTCOMPLEMENTOF:
                case OBJECTALLVALUESFROM:
                case OBJECTSOMEVALUESFROM:
                case OBJECTHASSELF:
                case OBJECTMINCARDINALITY:
                case OBJECTMAXCARDINALITY:
                case OBJECTEXACTCARDINALITY:
                case DATAALLVALUESFROM:
                case DATASOMEVALUESFROM:
                case DATAHASVALUE:
                case DATAMINCARDINALITY:
                case DATAMAXCARDINALITY:
                case DATAEXACTCARDINALITY:
                case FULLIRI:
                case PNAME_LN: {
                    ;
                    break;
                }
                default:
                    jj_la1[8] = jj_gen;
                    break label_4;
            }
            desc = ClassExpression();
            classExpressions.add(desc);
        }
        return classExpressions;
    }

    final public Set<OWLIndividual> IndividualMinOneSet() throws ParseException {
        Set<OWLIndividual> individuals = new HashSet<OWLIndividual>();
        OWLIndividual ind;
        ind = Individual();
        individuals.add(ind);
        label_5:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case FULLIRI:
                case PNAME_LN:
                case NODEID: {
                    ;
                    break;
                }
                default:
                    jj_la1[9] = jj_gen;
                    break label_5;
            }
            ind = Individual();
            individuals.add(ind);
        }
        return individuals;
    }

    final public OWLClassExpression ObjectUnionOf() throws ParseException {
        Set<OWLClassExpression> classExpressions;
        jj_consume_token(OBJECTUNIONOF);
        jj_consume_token(OPENPAR);
        classExpressions = ClassExpressionSet();
        jj_consume_token(CLOSEPAR);
        return df.getOWLObjectUnionOf(classExpressions);
    }

    final public OWLClassExpression ObjectIntersectionOf() throws ParseException {
        Set<OWLClassExpression> classExpressions;
        jj_consume_token(OBJECTINTERSECTIONOF);
        jj_consume_token(OPENPAR);
        classExpressions = ClassExpressionSet();
        jj_consume_token(CLOSEPAR);
        return df.getOWLObjectIntersectionOf(classExpressions);
    }

    final public OWLClassExpression ObjectComplementOf() throws ParseException {
        OWLClassExpression operand;
        jj_consume_token(OBJECTCOMPLEMENTOF);
        jj_consume_token(OPENPAR);
        operand = ClassExpression();
        jj_consume_token(CLOSEPAR);
        return df.getOWLObjectComplementOf(operand);
    }

    final public OWLClassExpression ObjectOneOf() throws ParseException {
        Set<OWLIndividual> individuals;
        jj_consume_token(OBJECTONEOF);
        jj_consume_token(OPENPAR);
        individuals = IndividualMinOneSet();
        jj_consume_token(CLOSEPAR);
        return df.getOWLObjectOneOf(individuals);
    }

    final public OWLClassExpression ObjectAllValuesFrom() throws ParseException {
        OWLObjectPropertyExpression prop;
        OWLClassExpression filler;
        jj_consume_token(OBJECTALLVALUESFROM);
        jj_consume_token(OPENPAR);
        prop = ObjectPropertyExpression();
        filler = ClassExpression();
        jj_consume_token(CLOSEPAR);
        return df.getOWLObjectAllValuesFrom(prop, filler);
    }

    final public OWLClassExpression ObjectSomeValuesFrom() throws ParseException {
        OWLObjectPropertyExpression prop;
        OWLClassExpression filler;
        jj_consume_token(OBJECTSOMEVALUESFROM);
        jj_consume_token(OPENPAR);
        prop = ObjectPropertyExpression();
        filler = ClassExpression();
        jj_consume_token(CLOSEPAR);
        return df.getOWLObjectSomeValuesFrom(prop, filler);
    }

    final public OWLClassExpression ObjectHasValue() throws ParseException {
        OWLObjectPropertyExpression prop;
        OWLIndividual ind;
        jj_consume_token(OBJECTHASVALUE);
        jj_consume_token(OPENPAR);
        prop = ObjectPropertyExpression();
        ind = Individual();
        jj_consume_token(CLOSEPAR);
        return df.getOWLObjectHasValue(prop, ind);
    }

    final public OWLClassExpression ObjectSelf() throws ParseException {
        OWLObjectPropertyExpression prop;
        jj_consume_token(OBJECTHASSELF);
        jj_consume_token(OPENPAR);
        prop = ObjectPropertyExpression();
        jj_consume_token(CLOSEPAR);
        return df.getOWLObjectHasSelf(prop);
    }

    final public OWLClassExpression ObjectMinCardinality() throws ParseException {
        int cardinality = 0;
        OWLObjectPropertyExpression prop = null;
        OWLClassExpression filler = null;
        jj_consume_token(OBJECTMINCARDINALITY);
        jj_consume_token(OPENPAR);
        cardinality = Cardinality();
        prop = ObjectPropertyExpression();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case OBJECTONEOF:
            case OBJECTUNIONOF:
            case OBJECTHASVALUE:
            case OBJECTINTERSECTIONOF:
            case OBJECTCOMPLEMENTOF:
            case OBJECTALLVALUESFROM:
            case OBJECTSOMEVALUESFROM:
            case OBJECTHASSELF:
            case OBJECTMINCARDINALITY:
            case OBJECTMAXCARDINALITY:
            case OBJECTEXACTCARDINALITY:
            case DATAALLVALUESFROM:
            case DATASOMEVALUESFROM:
            case DATAHASVALUE:
            case DATAMINCARDINALITY:
            case DATAMAXCARDINALITY:
            case DATAEXACTCARDINALITY:
            case FULLIRI:
            case PNAME_LN: {
                filler = ClassExpression();
                break;
            }
            default:
                jj_la1[10] = jj_gen;
                ;
        }
        jj_consume_token(CLOSEPAR);
        if (filler == null) {
            return df.getOWLObjectMinCardinality(cardinality, prop);
        }
        return df.getOWLObjectMinCardinality(cardinality, prop, filler);
    }

    final public OWLClassExpression ObjectExactCardinality() throws ParseException {
        int cardinality = 0;
        OWLObjectPropertyExpression prop = null;
        OWLClassExpression filler = null;
        jj_consume_token(OBJECTEXACTCARDINALITY);
        jj_consume_token(OPENPAR);
        cardinality = Cardinality();
        prop = ObjectPropertyExpression();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case OBJECTONEOF:
            case OBJECTUNIONOF:
            case OBJECTHASVALUE:
            case OBJECTINTERSECTIONOF:
            case OBJECTCOMPLEMENTOF:
            case OBJECTALLVALUESFROM:
            case OBJECTSOMEVALUESFROM:
            case OBJECTHASSELF:
            case OBJECTMINCARDINALITY:
            case OBJECTMAXCARDINALITY:
            case OBJECTEXACTCARDINALITY:
            case DATAALLVALUESFROM:
            case DATASOMEVALUESFROM:
            case DATAHASVALUE:
            case DATAMINCARDINALITY:
            case DATAMAXCARDINALITY:
            case DATAEXACTCARDINALITY:
            case FULLIRI:
            case PNAME_LN: {
                filler = ClassExpression();
                break;
            }
            default:
                jj_la1[11] = jj_gen;
                ;
        }
        jj_consume_token(CLOSEPAR);
        if (filler == null) {
            return df.getOWLObjectExactCardinality(cardinality, prop);
        }
        return df.getOWLObjectExactCardinality(cardinality, prop, filler);
    }

    final public OWLClassExpression ObjectMaxCardinality() throws ParseException {
        int cardinality = 0;
        OWLObjectPropertyExpression prop = null;
        OWLClassExpression filler = null;
        jj_consume_token(OBJECTMAXCARDINALITY);
        jj_consume_token(OPENPAR);
        cardinality = Cardinality();
        prop = ObjectPropertyExpression();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case OBJECTONEOF:
            case OBJECTUNIONOF:
            case OBJECTHASVALUE:
            case OBJECTINTERSECTIONOF:
            case OBJECTCOMPLEMENTOF:
            case OBJECTALLVALUESFROM:
            case OBJECTSOMEVALUESFROM:
            case OBJECTHASSELF:
            case OBJECTMINCARDINALITY:
            case OBJECTMAXCARDINALITY:
            case OBJECTEXACTCARDINALITY:
            case DATAALLVALUESFROM:
            case DATASOMEVALUESFROM:
            case DATAHASVALUE:
            case DATAMINCARDINALITY:
            case DATAMAXCARDINALITY:
            case DATAEXACTCARDINALITY:
            case FULLIRI:
            case PNAME_LN: {
                filler = ClassExpression();
                break;
            }
            default:
                jj_la1[12] = jj_gen;
                ;
        }
        jj_consume_token(CLOSEPAR);
        if (filler == null) {
            return df.getOWLObjectMaxCardinality(cardinality, prop);
        }
        return df.getOWLObjectMaxCardinality(cardinality, prop, filler);
    }

    final public OWLClassExpression DataAllValuesFrom() throws ParseException {
        OWLDataPropertyExpression prop = null;
        OWLDataRange dataRange = null;
        jj_consume_token(DATAALLVALUESFROM);
        jj_consume_token(OPENPAR);
        prop = DataPropertyExpression();
        dataRange = DataRange();
        jj_consume_token(CLOSEPAR);
        return df.getOWLDataAllValuesFrom(prop, dataRange);
    }

    final public OWLClassExpression DataSomeValuesFrom() throws ParseException {
        OWLDataPropertyExpression prop = null;
        OWLDataRange dataRange = null;
        jj_consume_token(DATASOMEVALUESFROM);
        jj_consume_token(OPENPAR);
        prop = DataPropertyExpression();
        dataRange = DataRange();
        jj_consume_token(CLOSEPAR);
        return df.getOWLDataSomeValuesFrom(prop, dataRange);
    }

    final public OWLClassExpression DataHasValue() throws ParseException {
        OWLDataPropertyExpression prop = null;
        OWLLiteral literal = null;
        jj_consume_token(DATAHASVALUE);
        jj_consume_token(OPENPAR);
        prop = DataPropertyExpression();
        literal = Literal();
        jj_consume_token(CLOSEPAR);
        return df.getOWLDataHasValue(prop, literal);
    }

    final public OWLClassExpression DataMinCardinality() throws ParseException {
        int cardinality = 0;
        OWLDataPropertyExpression prop = null;
        OWLDataRange rng = null;
        jj_consume_token(DATAMINCARDINALITY);
        jj_consume_token(OPENPAR);
        cardinality = Cardinality();
        prop = DataPropertyExpression();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case DATAONEOF:
            case DATAUNIONOF:
            case DATAINTERSECTIONOF:
            case DATACOMPLEMENTOF:
            case DATATYPERESTRICTION:
            case FULLIRI:
            case PNAME_LN: {
                rng = DataRange();
                break;
            }
            default:
                jj_la1[13] = jj_gen;
                ;
        }
        jj_consume_token(CLOSEPAR);
        if (rng == null) {
            return df.getOWLDataMinCardinality(cardinality, prop);
        }
        return df.getOWLDataMinCardinality(cardinality, prop, rng);
    }

    final public OWLClassExpression DataExactCardinality() throws ParseException {
        int cardinality = 0;
        OWLDataPropertyExpression prop = null;
        OWLDataRange rng = null;
        jj_consume_token(DATAEXACTCARDINALITY);
        jj_consume_token(OPENPAR);
        cardinality = Cardinality();
        prop = DataPropertyExpression();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case DATAONEOF:
            case DATAUNIONOF:
            case DATAINTERSECTIONOF:
            case DATACOMPLEMENTOF:
            case DATATYPERESTRICTION:
            case FULLIRI:
            case PNAME_LN: {
                rng = DataRange();
                break;
            }
            default:
                jj_la1[14] = jj_gen;
                ;
        }
        jj_consume_token(CLOSEPAR);
        if (rng == null) {
            return df.getOWLDataExactCardinality(cardinality, prop);
        }
        return df.getOWLDataExactCardinality(cardinality, prop, rng);
    }

    final public OWLClassExpression DataMaxCardinality() throws ParseException {
        int cardinality = 0;
        OWLDataPropertyExpression prop = null;
        OWLDataRange rng = null;
        jj_consume_token(DATAMAXCARDINALITY);
        jj_consume_token(OPENPAR);
        cardinality = Cardinality();
        prop = DataPropertyExpression();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case DATAONEOF:
            case DATAUNIONOF:
            case DATAINTERSECTIONOF:
            case DATACOMPLEMENTOF:
            case DATATYPERESTRICTION:
            case FULLIRI:
            case PNAME_LN: {
                rng = DataRange();
                break;
            }
            default:
                jj_la1[15] = jj_gen;
                ;
        }
        jj_consume_token(CLOSEPAR);
        if (rng == null) {
            return df.getOWLDataMaxCardinality(cardinality, prop);
        }
        return df.getOWLDataMaxCardinality(cardinality, prop, rng);
    }

    final public OWLClass Class() throws ParseException {
        OWLClass cls;
        jj_consume_token(CLASS);
        jj_consume_token(OPENPAR);
        cls = ClassIRI();
        jj_consume_token(CLOSEPAR);
        return cls;
    }

    final public OWLObjectPropertyExpression ObjectPropertyExpression() throws ParseException {
        OWLObjectPropertyExpression prop;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case OBJECTINVERSEOF: {
                prop = InverseObjectProperty();
                break;
            }
            case FULLIRI:
            case PNAME_LN: {
                prop = ObjectPropertyIRI();
                break;
            }
            default:
                jj_la1[16] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return prop;
    }

    final public OWLObjectPropertyExpression InverseObjectProperty() throws ParseException {
        OWLObjectProperty prop;
        jj_consume_token(OBJECTINVERSEOF);
        jj_consume_token(OPENPAR);
        prop = ObjectPropertyIRI();
        jj_consume_token(CLOSEPAR);
        return df.getOWLObjectInverseOf(prop);
    }

    final public OWLObjectProperty ObjectProperty() throws ParseException {
        OWLObjectProperty prop;
        jj_consume_token(OBJECTPROP);
        jj_consume_token(OPENPAR);
        prop = ObjectPropertyIRI();
        jj_consume_token(CLOSEPAR);
        return prop;
    }

    final public OWLDataPropertyExpression DataPropertyExpression() throws ParseException {
        OWLDataPropertyExpression prop;
        prop = DataPropertyIRI();
        return prop;
    }

    final public OWLDataProperty DataPropertyIRI() throws ParseException {
        IRI iri;
        iri = IRI();
        return df.getOWLDataProperty(iri);
    }

    final public OWLDataProperty DataProperty() throws ParseException {
        OWLDataProperty prop;
        jj_consume_token(DATAPROP);
        jj_consume_token(OPENPAR);
        prop = DataPropertyIRI();
        jj_consume_token(CLOSEPAR);
        return prop;
    }

    final public OWLAnnotationProperty AnnotationProperty() throws ParseException {
        OWLAnnotationProperty prop;
        jj_consume_token(ANNOTATIONPROPERTY);
        jj_consume_token(OPENPAR);
        prop = AnnotationPropertyIRI();
        jj_consume_token(CLOSEPAR);
        return prop;
    }

    final public OWLAnnotationProperty AnnotationPropertyIRI() throws ParseException {
        IRI iri;
        iri = IRI();
        return df.getOWLAnnotationProperty(iri);
    }

    final public OWLNamedIndividual NamedIndividual() throws ParseException {
        OWLNamedIndividual ind;
        jj_consume_token(NAMEDINDIVIDUAL);
        jj_consume_token(OPENPAR);
        ind = IndividualIRI();
        jj_consume_token(CLOSEPAR);
        return ind;
    }

    final public OWLAnonymousIndividual AnonymousIndividual() throws ParseException {
        Token t;
        t = jj_consume_token(NODEID);
        return anonProvider.getOWLAnonymousIndividual(t.image.substring(2, t.image.length()));
    }

    final public OWLDatatype Datatype() throws ParseException {
        OWLDatatype dt;
        jj_consume_token(DATATYPE);
        jj_consume_token(OPENPAR);
        dt = DatatypeIRI();
        jj_consume_token(CLOSEPAR);
        return dt;
    }

    final public OWLDatatype DatatypeIRI() throws ParseException {
        IRI iri;
        iri = IRI();
        return df.getOWLDatatype(iri);
    }

    final public int Cardinality() throws ParseException {
        int card = 0;
        card = Integer();
        return card;
    }

    final public int Integer() throws ParseException {
        Token t;
        t = jj_consume_token(INT);
        return Integer.parseInt(t.image);
    }

    final public OWLDatatypeDefinitionAxiom DatatypeDefinitionAxiom() throws ParseException {
        OWLDatatype datatype;
        OWLDataRange dr;
        Set<OWLAnnotation> axAnnos;
        jj_consume_token(DATATYPEDEFINITION);
        jj_consume_token(OPENPAR);
        axAnnos = AxiomAnnotationSet();
        datatype = DatatypeIRI();
        dr = DataRange();
        jj_consume_token(CLOSEPAR);
        return df.getOWLDatatypeDefinitionAxiom(datatype, dr, axAnnos);
    }

    final public OWLDataRange DataRange() throws ParseException {
        OWLDataRange rng;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case FULLIRI:
            case PNAME_LN: {
                rng = DatatypeIRI();
                break;
            }
            case DATAONEOF: {
                rng = DataOneOf();
                break;
            }
            case DATACOMPLEMENTOF: {
                rng = DataComplementOf();
                break;
            }
            case DATATYPERESTRICTION: {
                rng = DataRangeRestriction();
                break;
            }
            case DATAINTERSECTIONOF: {
                rng = DataIntersectionOf();
                break;
            }
            case DATAUNIONOF: {
                rng = DataUnionOf();
                break;
            }
            default:
                jj_la1[17] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return rng;
    }

    final public OWLDataRange DataComplementOf() throws ParseException {
        OWLDataRange rng;
        jj_consume_token(DATACOMPLEMENTOF);
        jj_consume_token(OPENPAR);
        rng = DataRange();
        jj_consume_token(CLOSEPAR);
        return df.getOWLDataComplementOf(rng);
    }

    final public OWLDataRange DataOneOf() throws ParseException {
        Set<OWLLiteral> values = new HashSet<OWLLiteral>();
        OWLLiteral con = null;
        OWLDataRange rng = null;
        jj_consume_token(DATAONEOF);
        jj_consume_token(OPENPAR);
        label_6:
        while (true) {
            con = Literal();
            values.add(con);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case STRINGLITERAL: {
                    ;
                    break;
                }
                default:
                    jj_la1[18] = jj_gen;
                    break label_6;
            }
        }
        jj_consume_token(CLOSEPAR);
        return df.getOWLDataOneOf(values);
    }

    final public OWLDataRange DataUnionOf() throws ParseException {
        OWLDataRange dataRange;
        Set<OWLDataRange> ranges = new HashSet<OWLDataRange>();
        jj_consume_token(DATAUNIONOF);
        jj_consume_token(OPENPAR);
        label_7:
        while (true) {
            dataRange = DataRange();
            ranges.add(dataRange);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case DATAONEOF:
                case DATAUNIONOF:
                case DATAINTERSECTIONOF:
                case DATACOMPLEMENTOF:
                case DATATYPERESTRICTION:
                case FULLIRI:
                case PNAME_LN: {
                    ;
                    break;
                }
                default:
                    jj_la1[19] = jj_gen;
                    break label_7;
            }
        }
        jj_consume_token(CLOSEPAR);
        return df.getOWLDataUnionOf(ranges);
    }

    final public OWLDataRange DataIntersectionOf() throws ParseException {
        OWLDataRange dataRange;
        Set<OWLDataRange> ranges = new HashSet<OWLDataRange>();
        jj_consume_token(DATAINTERSECTIONOF);
        jj_consume_token(OPENPAR);
        label_8:
        while (true) {
            dataRange = DataRange();
            ranges.add(dataRange);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case DATAONEOF:
                case DATAUNIONOF:
                case DATAINTERSECTIONOF:
                case DATACOMPLEMENTOF:
                case DATATYPERESTRICTION:
                case FULLIRI:
                case PNAME_LN: {
                    ;
                    break;
                }
                default:
                    jj_la1[20] = jj_gen;
                    break label_8;
            }
        }
        jj_consume_token(CLOSEPAR);
        return df.getOWLDataIntersectionOf(ranges);
    }

    final public OWLDataRange DataRangeRestriction() throws ParseException {
        OWLFacet v;
        OWLDatatype rng;
        OWLFacetRestriction fr;
        Set<OWLFacetRestriction> frs = new HashSet<OWLFacetRestriction>();
        jj_consume_token(DATATYPERESTRICTION);
        jj_consume_token(OPENPAR);
        rng = DatatypeIRI();
        label_9:
        while (true) {
            fr = DataRangeFacetRestriction();
            frs.add(fr);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case FULLIRI:
                case PNAME_LN: {
                    ;
                    break;
                }
                default:
                    jj_la1[21] = jj_gen;
                    break label_9;
            }
        }
        jj_consume_token(CLOSEPAR);
        return df.getOWLDatatypeRestriction(rng, frs);
    }

    final public OWLFacetRestriction DataRangeFacetRestriction() throws ParseException {
        IRI iri;
        OWLLiteral con;
        iri = IRI();
        con = Literal();
        return df.getOWLFacetRestriction(OWLFacet.getFacetByShortName(iri.getFragment()), con);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Axioms
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
    final public OWLAxiom Axiom() throws ParseException {
        OWLAxiom ax;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case SUBCLASSOF:
            case EQUIVALENTCLASSES:
            case DISJOINTCLASSES:
            case DISJOINTUNION: {
                ax = ClassAxiom();
                break;
            }
            case INVERSEOBJECTPROPERTIES:
            case SUBOBJECTPROPERTYOF:
            case EQUIVALENTOBJECTPROPERTIES:
            case DISJOINTOBJECTPROPERTIES:
            case OBJECTPROPERTYDOMAIN:
            case OBJECTPROPERTYRANGE:
            case FUNCTIONALOBJECTPROPERTY:
            case INVERSEFUNCTIONALOBJECTPROPERTY:
            case REFLEXIVEOBJECTPROPERTY:
            case IRREFLEXIVEOBJECTPROPERTY:
            case SYMMETRICOBJECTPROPERTY:
            case ASYMMETRICOBJECTPROPERTY:
            case TRANSITIVEOBJECTPROPERTY: {
                ax = ObjectPropertyAxiom();
                break;
            }
            case SUBDATAPROPERTYOF:
            case EQUIVALENTDATAPROPERTIES:
            case DISJOINTDATAPROPERTIES:
            case DATAPROPERTYDOMAIN:
            case DATAPROPERTYRANGE:
            case FUNCTIONALDATAPROPERTY: {
                ax = DataPropertyAxiom();
                break;
            }
            case SAMEINDIVIDUAL:
            case DIFFERENTINDIVIDUALS:
            case CLASSASSERTION:
            case OBJECTPROPERTYASSERTION:
            case NEGATIVEOBJECTPROPERTYASSERTION:
            case DATAPROPERTYASSERTION:
            case NEGATIVEDATAPROPERTYASSERTION: {
                ax = IndividualAxiom();
                break;
            }
            case DECLARATION: {
                ax = Declaration();
                break;
            }
            case HASKEY: {
                ax = HasKey();
                break;
            }
            case DATATYPEDEFINITION: {
                ax = DatatypeDefinitionAxiom();
                break;
            }
            case ANNOTATIONASSERTION:
            case SUBANNOTATIONPROPERTYOF:
            case ANNOTATIONPROPERTYDOMAIN:
            case ANNOTATIONPROPERTYRANGE: {
                ax = AnnotationAxiom();
                break;
            }
            case DLSAFERULE: {
                ax = DLSafeRule();
                break;
            }
            default:
                jj_la1[22] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return ax;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Class Axioms
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
    final public OWLClassAxiom ClassAxiom() throws ParseException {
        OWLClassAxiom ax;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case SUBCLASSOF: {
                ax = SubClassOf();
                break;
            }
            case EQUIVALENTCLASSES: {
                ax = EquivalentClasses();
                break;
            }
            case DISJOINTCLASSES: {
                ax = DisjointClasses();
                break;
            }
            case DISJOINTUNION: {
                ax = DisjointUnion();
                break;
            }
            default:
                jj_la1[23] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return ax;
    }

    final public OWLClassAxiom SubClassOf() throws ParseException {
        OWLClassExpression subClass;
        OWLClassExpression superClass;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(SUBCLASSOF);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        subClass = ClassExpression();
        superClass = ClassExpression();
        jj_consume_token(CLOSEPAR);
        return df.getOWLSubClassOfAxiom(subClass, superClass, axiomAnnos);
    }

    final public OWLClassAxiom EquivalentClasses() throws ParseException {
        Set<OWLClassExpression> classExpressions;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(EQUIVALENTCLASSES);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        classExpressions = ClassExpressionSet();
        jj_consume_token(CLOSEPAR);
        return df.getOWLEquivalentClassesAxiom(classExpressions, axiomAnnos);
    }

    final public OWLClassAxiom DisjointClasses() throws ParseException {
        Set<OWLClassExpression> classExpressions;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(DISJOINTCLASSES);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        classExpressions = ClassExpressionSet();
        jj_consume_token(CLOSEPAR);
        return df.getOWLDisjointClassesAxiom(classExpressions, axiomAnnos);
    }

    final public OWLClassAxiom DisjointUnion() throws ParseException {
        OWLClass cls;
        Set<OWLClassExpression> classExpressions;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(DISJOINTUNION);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        cls = ClassIRI();
        classExpressions = ClassExpressionSet();
        jj_consume_token(CLOSEPAR);
        return df.getOWLDisjointUnionAxiom(cls, classExpressions, axiomAnnos);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Object Property Axioms
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
    final public OWLPropertyAxiom ObjectPropertyAxiom() throws ParseException {
        OWLPropertyAxiom ax;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case SUBOBJECTPROPERTYOF: {
                ax = SubObjectPropertyOf();
                break;
            }
            case EQUIVALENTOBJECTPROPERTIES: {
                ax = EquivalentObjectProperties();
                break;
            }
            case DISJOINTOBJECTPROPERTIES: {
                ax = DisjointObjectProperties();
                break;
            }
            case OBJECTPROPERTYRANGE: {
                ax = ObjectPropertyRange();
                break;
            }
            case OBJECTPROPERTYDOMAIN: {
                ax = ObjectPropertyDomain();
                break;
            }
            case FUNCTIONALOBJECTPROPERTY: {
                ax = FunctionalObjectProperty();
                break;
            }
            case INVERSEFUNCTIONALOBJECTPROPERTY: {
                ax = InverseFunctionalObjectProperty();
                break;
            }
            case SYMMETRICOBJECTPROPERTY: {
                ax = SymmetricObjectProperty();
                break;
            }
            case ASYMMETRICOBJECTPROPERTY: {
                ax = AsymmetricObjectProperty();
                break;
            }
            case REFLEXIVEOBJECTPROPERTY: {
                ax = ReflexiveObjectProperty();
                break;
            }
            case IRREFLEXIVEOBJECTPROPERTY: {
                ax = IrreflexiveObjectProperty();
                break;
            }
            case TRANSITIVEOBJECTPROPERTY: {
                ax = TransitiveObjectProperty();
                break;
            }
            case INVERSEOBJECTPROPERTIES: {
                ax = InverseObjectProperties();
                break;
            }
            default:
                jj_la1[24] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return ax;
    }

    final public List<OWLObjectPropertyExpression> SubObjectPropertyChain() throws ParseException {
        OWLObjectPropertyExpression prop;
        List<OWLObjectPropertyExpression> props = new ArrayList<OWLObjectPropertyExpression>();
        jj_consume_token(SUBOBJECTPROPERTYCHAIN);
        jj_consume_token(OPENPAR);
        prop = ObjectPropertyExpression();
        props.add(prop);
        label_10:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case OBJECTINVERSEOF:
                case FULLIRI:
                case PNAME_LN: {
                    ;
                    break;
                }
                default:
                    jj_la1[25] = jj_gen;
                    break label_10;
            }
            prop = ObjectPropertyExpression();
            props.add(prop);
        }
        jj_consume_token(CLOSEPAR);
        return props;
    }

    final public OWLPropertyAxiom SubObjectPropertyOf() throws ParseException {
        OWLObjectPropertyExpression subProperty = null;
        List<OWLObjectPropertyExpression> chain = null;
        OWLObjectPropertyExpression superProperty = null;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(SUBOBJECTPROPERTYOF);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case OBJECTINVERSEOF:
            case FULLIRI:
            case PNAME_LN: {
                subProperty = ObjectPropertyExpression();
                break;
            }
            case SUBOBJECTPROPERTYCHAIN: {
                chain = SubObjectPropertyChain();
                break;
            }
            default:
                jj_la1[26] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        superProperty = ObjectPropertyExpression();
        jj_consume_token(CLOSEPAR);
        if (subProperty != null) {
            return df.getOWLSubObjectPropertyOfAxiom(subProperty, superProperty, axiomAnnos);
        }
        if (chain != null) {
            return df.getOWLSubPropertyChainOfAxiom(chain, superProperty, axiomAnnos);
        }
        return null;
    }

    final public OWLPropertyAxiom EquivalentObjectProperties() throws ParseException {
        Set<OWLObjectPropertyExpression> props;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(EQUIVALENTOBJECTPROPERTIES);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        props = ObjectPropertySet();
        jj_consume_token(CLOSEPAR);
        return df.getOWLEquivalentObjectPropertiesAxiom(props, axiomAnnos);
    }

    final public OWLPropertyAxiom DisjointObjectProperties() throws ParseException {
        Set<OWLObjectPropertyExpression> props;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(DISJOINTOBJECTPROPERTIES);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        props = ObjectPropertySet();
        jj_consume_token(CLOSEPAR);
        return df.getOWLDisjointObjectPropertiesAxiom(props, axiomAnnos);
    }

    final public Set<OWLObjectPropertyExpression> ObjectPropertySet() throws ParseException {
        OWLObjectPropertyExpression prop;
        Set<OWLObjectPropertyExpression> props = new HashSet<OWLObjectPropertyExpression>();
        prop = ObjectPropertyExpression();
        props.add(prop);
        prop = ObjectPropertyExpression();
        props.add(prop);
        label_11:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case OBJECTINVERSEOF:
                case FULLIRI:
                case PNAME_LN: {
                    ;
                    break;
                }
                default:
                    jj_la1[27] = jj_gen;
                    break label_11;
            }
            prop = ObjectPropertyExpression();
            props.add(prop);
        }
        return props;
    }

    final public OWLPropertyAxiom ObjectPropertyRange() throws ParseException {
        OWLObjectPropertyExpression prop;
        OWLClassExpression range;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(OBJECTPROPERTYRANGE);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        prop = ObjectPropertyExpression();
        range = ClassExpression();
        jj_consume_token(CLOSEPAR);
        return df.getOWLObjectPropertyRangeAxiom(prop, range, axiomAnnos);
    }

    final public OWLPropertyAxiom ObjectPropertyDomain() throws ParseException {
        OWLObjectPropertyExpression prop;
        OWLClassExpression desc;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(OBJECTPROPERTYDOMAIN);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        prop = ObjectPropertyExpression();
        desc = ClassExpression();
        jj_consume_token(CLOSEPAR);
        return df.getOWLObjectPropertyDomainAxiom(prop, desc, axiomAnnos);
    }

    final public OWLPropertyAxiom FunctionalObjectProperty() throws ParseException {
        OWLObjectPropertyExpression prop;
        Set<OWLAnnotation> axiomAnnos = Collections.emptySet();
        jj_consume_token(FUNCTIONALOBJECTPROPERTY);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        prop = ObjectPropertyExpression();
        jj_consume_token(CLOSEPAR);
        return df.getOWLFunctionalObjectPropertyAxiom(prop, axiomAnnos);
    }

    final public OWLPropertyAxiom InverseObjectProperties() throws ParseException {
        OWLObjectPropertyExpression propA;
        OWLObjectPropertyExpression propB;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(INVERSEOBJECTPROPERTIES);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        propA = ObjectPropertyExpression();
        propB = ObjectPropertyExpression();
        jj_consume_token(CLOSEPAR);
        return df.getOWLInverseObjectPropertiesAxiom(propA, propB, axiomAnnos);
    }

    final public OWLPropertyAxiom InverseFunctionalObjectProperty() throws ParseException {
        OWLObjectPropertyExpression prop;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(INVERSEFUNCTIONALOBJECTPROPERTY);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        prop = ObjectPropertyExpression();
        jj_consume_token(CLOSEPAR);
        return df.getOWLInverseFunctionalObjectPropertyAxiom(prop, axiomAnnos);
    }

    final public OWLPropertyAxiom SymmetricObjectProperty() throws ParseException {
        OWLObjectPropertyExpression prop;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(SYMMETRICOBJECTPROPERTY);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        prop = ObjectPropertyExpression();
        jj_consume_token(CLOSEPAR);
        return df.getOWLSymmetricObjectPropertyAxiom(prop, axiomAnnos);
    }

    final public OWLPropertyAxiom AsymmetricObjectProperty() throws ParseException {
        OWLObjectPropertyExpression prop;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(ASYMMETRICOBJECTPROPERTY);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        prop = ObjectPropertyExpression();
        jj_consume_token(CLOSEPAR);
        return df.getOWLAsymmetricObjectPropertyAxiom(prop, axiomAnnos);
    }

    final public OWLPropertyAxiom ReflexiveObjectProperty() throws ParseException {
        OWLObjectPropertyExpression prop;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(REFLEXIVEOBJECTPROPERTY);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        prop = ObjectPropertyExpression();
        jj_consume_token(CLOSEPAR);
        return df.getOWLReflexiveObjectPropertyAxiom(prop, axiomAnnos);
    }

    final public OWLPropertyAxiom IrreflexiveObjectProperty() throws ParseException {
        OWLObjectPropertyExpression prop;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(IRREFLEXIVEOBJECTPROPERTY);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        prop = ObjectPropertyExpression();
        jj_consume_token(CLOSEPAR);
        return df.getOWLIrreflexiveObjectPropertyAxiom(prop, axiomAnnos);
    }

    final public OWLPropertyAxiom TransitiveObjectProperty() throws ParseException {
        OWLObjectPropertyExpression prop;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(TRANSITIVEOBJECTPROPERTY);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        prop = ObjectPropertyExpression();
        jj_consume_token(CLOSEPAR);
        return df.getOWLTransitiveObjectPropertyAxiom(prop, axiomAnnos);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Data Property Axioms
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
    final public OWLPropertyAxiom DataPropertyAxiom() throws ParseException {
        OWLPropertyAxiom ax;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case SUBDATAPROPERTYOF: {
                ax = SubDataPropertyOf();
                break;
            }
            case EQUIVALENTDATAPROPERTIES: {
                ax = EquivalentDataProperties();
                break;
            }
            case DISJOINTDATAPROPERTIES: {
                ax = DisjointDataProperties();
                break;
            }
            case DATAPROPERTYRANGE: {
                ax = DataPropertyRange();
                break;
            }
            case DATAPROPERTYDOMAIN: {
                ax = DataPropertyDomain();
                break;
            }
            case FUNCTIONALDATAPROPERTY: {
                ax = FunctionalDataProperty();
                break;
            }
            default:
                jj_la1[28] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return ax;
    }

    final public OWLPropertyAxiom SubDataPropertyOf() throws ParseException {
        OWLDataPropertyExpression subProperty;
        OWLDataPropertyExpression superProperty;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(SUBDATAPROPERTYOF);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        subProperty = DataPropertyExpression();
        superProperty = DataPropertyExpression();
        jj_consume_token(CLOSEPAR);
        return df.getOWLSubDataPropertyOfAxiom(subProperty, superProperty, axiomAnnos);
    }

    final public OWLPropertyAxiom EquivalentDataProperties() throws ParseException {
        Set<OWLDataPropertyExpression> props;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(EQUIVALENTDATAPROPERTIES);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        props = DataPropertySet();
        jj_consume_token(CLOSEPAR);
        return df.getOWLEquivalentDataPropertiesAxiom(props, axiomAnnos);
    }

    final public OWLPropertyAxiom DisjointDataProperties() throws ParseException {
        Set<OWLDataPropertyExpression> props;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(DISJOINTDATAPROPERTIES);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        props = DataPropertySet();
        jj_consume_token(CLOSEPAR);
        return df.getOWLDisjointDataPropertiesAxiom(props, axiomAnnos);
    }

    final public Set<OWLDataPropertyExpression> DataPropertySet() throws ParseException {
        OWLDataPropertyExpression prop;
        Set<OWLDataPropertyExpression> props = new HashSet<OWLDataPropertyExpression>();
        prop = DataPropertyExpression();
        props.add(prop);
        prop = DataPropertyExpression();
        props.add(prop);
        label_12:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case FULLIRI:
                case PNAME_LN: {
                    ;
                    break;
                }
                default:
                    jj_la1[29] = jj_gen;
                    break label_12;
            }
            prop = DataPropertyExpression();
            props.add(prop);
        }
        return props;
    }

    final public OWLPropertyAxiom DataPropertyDomain() throws ParseException {
        OWLDataPropertyExpression prop;
        OWLClassExpression domain;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(DATAPROPERTYDOMAIN);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        prop = DataPropertyExpression();
        domain = ClassExpression();
        jj_consume_token(CLOSEPAR);
        return df.getOWLDataPropertyDomainAxiom(prop, domain, axiomAnnos);
    }

    final public OWLPropertyAxiom DataPropertyRange() throws ParseException {
        OWLDataPropertyExpression prop;
        OWLDataRange rng;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(DATAPROPERTYRANGE);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        prop = DataPropertyExpression();
        rng = DataRange();
        jj_consume_token(CLOSEPAR);
        return df.getOWLDataPropertyRangeAxiom(prop, rng, axiomAnnos);
    }

    final public OWLPropertyAxiom FunctionalDataProperty() throws ParseException {
        OWLDataPropertyExpression prop;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(FUNCTIONALDATAPROPERTY);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        prop = DataPropertyExpression();
        jj_consume_token(CLOSEPAR);
        return df.getOWLFunctionalDataPropertyAxiom(prop, axiomAnnos);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Individual Axioms
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
    final public OWLIndividualAxiom IndividualAxiom() throws ParseException {
        OWLIndividualAxiom ax;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case SAMEINDIVIDUAL: {
                ax = SameIndividuals();
                break;
            }
            case DIFFERENTINDIVIDUALS: {
                ax = DifferentIndividuals();
                break;
            }
            case CLASSASSERTION: {
                ax = ClassAssertion();
                break;
            }
            case OBJECTPROPERTYASSERTION: {
                ax = ObjectPropertyAssertion();
                break;
            }
            case DATAPROPERTYASSERTION: {
                ax = DataPropertyAssertion();
                break;
            }
            case NEGATIVEOBJECTPROPERTYASSERTION: {
                ax = NegativeObjectPropertyAssertion();
                break;
            }
            case NEGATIVEDATAPROPERTYASSERTION: {
                ax = NegativeDataPropertyAssertion();
                break;
            }
            default:
                jj_la1[30] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return ax;
    }

    final public Set<OWLIndividual> IndividualSet() throws ParseException {
        OWLIndividual ind;
        Set<OWLIndividual> individuals = new HashSet<OWLIndividual>();
        ind = Individual();
        individuals.add(ind);
        ind = Individual();
        individuals.add(ind);
        label_13:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case FULLIRI:
                case PNAME_LN:
                case NODEID: {
                    ;
                    break;
                }
                default:
                    jj_la1[31] = jj_gen;
                    break label_13;
            }
            ind = Individual();
            individuals.add(ind);
        }
        return individuals;
    }

    final public OWLIndividualAxiom SameIndividuals() throws ParseException {
        Set<OWLIndividual> individuals;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(SAMEINDIVIDUAL);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        individuals = IndividualSet();
        jj_consume_token(CLOSEPAR);
        return df.getOWLSameIndividualAxiom(individuals, axiomAnnos);
    }

    final public OWLIndividualAxiom DifferentIndividuals() throws ParseException {
        Set<OWLIndividual> individuals;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(DIFFERENTINDIVIDUALS);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        individuals = IndividualSet();
        jj_consume_token(CLOSEPAR);
        return df.getOWLDifferentIndividualsAxiom(individuals, axiomAnnos);
    }

    final public OWLIndividualAxiom ClassAssertion() throws ParseException {
        OWLIndividual ind;
        OWLClassExpression desc;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(CLASSASSERTION);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        desc = ClassExpression();
        ind = Individual();
        jj_consume_token(CLOSEPAR);
        return df.getOWLClassAssertionAxiom(desc, ind, axiomAnnos);
    }

    final public OWLIndividualAxiom ObjectPropertyAssertion() throws ParseException {
        OWLIndividual subj;
        OWLObjectPropertyExpression prop;
        OWLIndividual obj;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(OBJECTPROPERTYASSERTION);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        prop = ObjectPropertyExpression();
        subj = Individual();
        obj = Individual();
        jj_consume_token(CLOSEPAR);
        return df.getOWLObjectPropertyAssertionAxiom(prop, subj, obj, axiomAnnos);
    }

    final public OWLIndividualAxiom NegativeObjectPropertyAssertion() throws ParseException {
        OWLIndividual subj;
        OWLObjectPropertyExpression prop;
        OWLIndividual obj;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(NEGATIVEOBJECTPROPERTYASSERTION);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        prop = ObjectPropertyExpression();
        subj = Individual();
        obj = Individual();
        jj_consume_token(CLOSEPAR);
        return df.getOWLNegativeObjectPropertyAssertionAxiom(prop, subj, obj, axiomAnnos);
    }

    final public OWLIndividualAxiom DataPropertyAssertion() throws ParseException {
        OWLIndividual subj;
        OWLDataPropertyExpression prop;
        OWLLiteral obj;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(DATAPROPERTYASSERTION);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        prop = DataPropertyExpression();
        subj = Individual();
        obj = Literal();
        jj_consume_token(CLOSEPAR);
        return df.getOWLDataPropertyAssertionAxiom(prop, subj, obj, axiomAnnos);
    }

    final public OWLIndividualAxiom NegativeDataPropertyAssertion() throws ParseException {
        OWLIndividual subj;
        OWLDataPropertyExpression prop;
        OWLLiteral obj;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(NEGATIVEDATAPROPERTYASSERTION);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        prop = DataPropertyExpression();
        subj = Individual();
        obj = Literal();
        jj_consume_token(CLOSEPAR);
        return df.getOWLNegativeDataPropertyAssertionAxiom(prop, subj, obj, axiomAnnos);
    }

    final public OWLNamedIndividual IndividualIRI() throws ParseException {
        IRI iri;
        iri = IRI();
        return df.getOWLNamedIndividual(iri);
    }

    final public OWLIndividual Individual() throws ParseException {
        OWLIndividual ind;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case FULLIRI:
            case PNAME_LN: {
                ind = IndividualIRI();
                break;
            }
            case NODEID: {
                ind = AnonymousIndividual();
                break;
            }
            default:
                jj_la1[32] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return ind;
    }

    final public OWLObjectProperty ObjectPropertyIRI() throws ParseException {
        IRI iri;
        iri = IRI();
        return df.getOWLObjectProperty(iri);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Annotation Stuff
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    final public OWLAxiom AnnotationAxiom() throws ParseException {
        OWLAxiom axiom;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case ANNOTATIONASSERTION: {
                axiom = AnnotationAssertion();
                break;
            }
            case ANNOTATIONPROPERTYDOMAIN: {
                axiom = AnnotationPropertyDomain();
                break;
            }
            case ANNOTATIONPROPERTYRANGE: {
                axiom = AnnotationPropertyRange();
                break;
            }
            case SUBANNOTATIONPROPERTYOF: {
                axiom = SubAnnotationPropertyOf();
                break;
            }
            default:
                jj_la1[33] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return axiom;
    }

    final public OWLAnnotation Annotation() throws ParseException {
        OWLAnnotationProperty prop;
        OWLAnnotationValue val;
        Set<OWLAnnotation> annos = new HashSet<OWLAnnotation>();
        OWLAnnotation anno = null;
        jj_consume_token(ANNOTATION);
        jj_consume_token(OPENPAR);
        label_14:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case ANNOTATION: {
                    ;
                    break;
                }
                default:
                    jj_la1[34] = jj_gen;
                    break label_14;
            }
            anno = Annotation();
            annos.add(anno);
        }
        prop = AnnotationPropertyIRI();
        val = AnnotationValue();
        jj_consume_token(CLOSEPAR);
        return df.getOWLAnnotation(prop, val, annos);
    }

    final public OWLAnnotationSubject AnnotationSubject() throws ParseException {
        OWLAnnotationSubject subj;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case FULLIRI:
            case PNAME_LN: {
                subj = IRI();
                break;
            }
            case NODEID: {
                subj = AnonymousIndividual();
                break;
            }
            default:
                jj_la1[35] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return subj;
    }

    final public OWLAnnotationValue AnnotationValue() throws ParseException {
        OWLAnnotationValue value;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case FULLIRI:
            case PNAME_LN: {
                value = IRI();
                break;
            }
            case NODEID: {
                value = AnonymousIndividual();
                break;
            }
            case STRINGLITERAL: {
                value = Literal();
                break;
            }
            default:
                jj_la1[36] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return value;
    }

    final public Set<OWLAnnotation> AxiomAnnotationSet() throws ParseException {
        Set<OWLAnnotation> annos = new HashSet<OWLAnnotation>();
        OWLAnnotation anno;
        label_15:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case ANNOTATION: {
                    ;
                    break;
                }
                default:
                    jj_la1[37] = jj_gen;
                    break label_15;
            }
            anno = Annotation();
            annos.add(anno);
        }
        return annos;
    }

    final public OWLImportsDeclaration ImportsDeclaration() throws ParseException {
        IRI iri;
        jj_consume_token(IMPORT);
        jj_consume_token(OPENPAR);
        iri = IRI();
        jj_consume_token(CLOSEPAR);
        return df.getOWLImportsDeclaration(iri);
    }

    final public OWLAnnotationAssertionAxiom AnnotationAssertion() throws ParseException {
        OWLAnnotationProperty prop;
        OWLAnnotationSubject subj;
        OWLAnnotationValue val;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(ANNOTATIONASSERTION);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        prop = AnnotationPropertyIRI();
        subj = AnnotationSubject();
        val = AnnotationValue();
        jj_consume_token(CLOSEPAR);
        return df.getOWLAnnotationAssertionAxiom(prop, subj, val, axiomAnnos);
    }

    final public OWLSubAnnotationPropertyOfAxiom SubAnnotationPropertyOf() throws ParseException {
        OWLAnnotationProperty subProp;
        OWLAnnotationProperty superProperty;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(SUBANNOTATIONPROPERTYOF);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        subProp = AnnotationPropertyIRI();
        superProperty = AnnotationPropertyIRI();
        jj_consume_token(CLOSEPAR);
        return df.getOWLSubAnnotationPropertyOfAxiom(subProp, superProperty, axiomAnnos);
    }

    final public OWLAnnotationPropertyDomainAxiom AnnotationPropertyDomain() throws ParseException {
        IRI domain;
        OWLAnnotationProperty prop;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(ANNOTATIONPROPERTYDOMAIN);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        prop = AnnotationPropertyIRI();
        domain = IRI();
        jj_consume_token(CLOSEPAR);
        return df.getOWLAnnotationPropertyDomainAxiom(prop, domain, axiomAnnos);
    }

    final public OWLAnnotationPropertyRangeAxiom AnnotationPropertyRange() throws ParseException {
        IRI range;
        OWLAnnotationProperty prop;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(ANNOTATIONPROPERTYRANGE);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        prop = AnnotationPropertyIRI();
        range = IRI();
        jj_consume_token(CLOSEPAR);
        return df.getOWLAnnotationPropertyRangeAxiom(prop, range, axiomAnnos);
    }

    final public OWLHasKeyAxiom HasKey() throws ParseException {
        OWLClassExpression ce;
        OWLPropertyExpression prop;
        Set<OWLPropertyExpression> props = new HashSet<OWLPropertyExpression>();
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(HASKEY);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        ce = ClassExpression();
        jj_consume_token(OPENPAR);
        label_16:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case OBJECTINVERSEOF:
                case FULLIRI:
                case PNAME_LN: {
                    ;
                    break;
                }
                default:
                    jj_la1[38] = jj_gen;
                    break label_16;
            }
            prop = ObjectPropertyExpression();
            props.add(prop);
        }
        jj_consume_token(CLOSEPAR);
        jj_consume_token(OPENPAR);
        label_17:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case FULLIRI:
                case PNAME_LN: {
                    ;
                    break;
                }
                default:
                    jj_la1[39] = jj_gen;
                    break label_17;
            }
            prop = DataPropertyExpression();
            props.add(prop);
        }
        jj_consume_token(CLOSEPAR);
        jj_consume_token(CLOSEPAR);
        return df.getOWLHasKeyAxiom(ce, props, axiomAnnos);
    }

    final public OWLAxiom Declaration() throws ParseException {
        OWLEntity entity = null;
        IRI iri = null;
        OWLLiteral con = null;
        Set<OWLAnnotation> axiomAnnos;
        jj_consume_token(DECLARATION);
        jj_consume_token(OPENPAR);
        axiomAnnos = AxiomAnnotationSet();
        entity = Entity();
        jj_consume_token(CLOSEPAR);
        return ignoreAnnotationsAndDeclarations ? null
            : df.getOWLDeclarationAxiom(entity, axiomAnnos);
    }

    final public OWLEntity Entity() throws ParseException {
        OWLEntity entity;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case CLASS: {
                entity = Class();
                break;
            }
            case OBJECTPROP: {
                entity = ObjectProperty();
                break;
            }
            case DATAPROP: {
                entity = DataProperty();
                break;
            }
            case NAMEDINDIVIDUAL: {
                entity = NamedIndividual();
                break;
            }
            case DATATYPE: {
                entity = Datatype();
                break;
            }
            case ANNOTATIONPROPERTY: {
                entity = AnnotationProperty();
                break;
            }
            default:
                jj_la1[40] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return entity;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Data Stuff
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    final public OWLLiteral Literal() throws ParseException {
        boolean plain = true;
        String literal;
        OWLDatatype datatype = null;
        String lang = "";
        literal = QuotedString();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case LANGIDENTIFIER:
            case DATATYPEIDENTIFIER: {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case DATATYPEIDENTIFIER: {
                        jj_consume_token(DATATYPEIDENTIFIER);
                        plain = false;
                        datatype = DatatypeIRI();
                        break;
                    }
                    case LANGIDENTIFIER: {
                        jj_consume_token(LANGIDENTIFIER);
                        lang = LangTag();
                        break;
                    }
                    default:
                        jj_la1[41] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                break;
            }
            default:
                jj_la1[42] = jj_gen;
                ;
        }
        if (plain) {
            return df.getOWLLiteral(literal, lang);
        }
        // a float value in this syntax has an extra 'f' or 'F' character that must be removed to make a valid OWL literal
        if (datatype.isFloat() && (literal.endsWith("f") || literal.endsWith("F")) && !(
            literal.endsWith("inf") || literal.endsWith("INF"))) {
            literal = literal.substring(0, literal.length() - 1);
        }
        return df.getOWLLiteral(literal, datatype);
    }

    final public String QuotedString() throws ParseException {
        Token t;
        t = jj_consume_token(STRINGLITERAL);
        return EscapeUtils.unescapeString(t.image.substring(1, t.image.length() - 1));
    }

    final public String LangTag() throws ParseException {
        Token t;
        t = jj_consume_token(PN_LOCAL);
        return t.image;
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Rules
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
    final public SWRLRule DLSafeRule() throws ParseException {
        Set<OWLAnnotation> annos;
        SWRLAtom atom;
        Set<SWRLAtom> body;
        Set<SWRLAtom> head;
        jj_consume_token(DLSAFERULE);
        jj_consume_token(OPENPAR);
        annos = AxiomAnnotationSet();
        jj_consume_token(BODY);
        body = new LinkedHashSet<SWRLAtom>();
        jj_consume_token(OPENPAR);
        label_18:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case CLASSATOM:
                case DATARANGEATOM:
                case OBJECTPROPERTYATOM:
                case DATAPROPERTYATOM:
                case BUILTINATOM:
                case SAMEINDIVIDUALATOM:
                case DIFFERENTINDIVIDUALSATOM: {
                    ;
                    break;
                }
                default:
                    jj_la1[43] = jj_gen;
                    break label_18;
            }
            atom = Atom();
            body.add(atom);
        }
        jj_consume_token(CLOSEPAR);
        jj_consume_token(HEAD);
        head = new LinkedHashSet<SWRLAtom>();
        jj_consume_token(OPENPAR);
        label_19:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case CLASSATOM:
                case DATARANGEATOM:
                case OBJECTPROPERTYATOM:
                case DATAPROPERTYATOM:
                case BUILTINATOM:
                case SAMEINDIVIDUALATOM:
                case DIFFERENTINDIVIDUALSATOM: {
                    ;
                    break;
                }
                default:
                    jj_la1[44] = jj_gen;
                    break label_19;
            }
            atom = Atom();
            head.add(atom);
        }
        jj_consume_token(CLOSEPAR);
        jj_consume_token(CLOSEPAR);
        return df.getSWRLRule(body, head, annos);
    }

    final public SWRLAtom Atom() throws ParseException {
        SWRLAtom a;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case CLASSATOM: {
                a = ClassAtom();
                break;
            }
            case DATARANGEATOM: {
                a = DataRangeAtom();
                break;
            }
            case OBJECTPROPERTYATOM: {
                a = ObjectPropertyAtom();
                break;
            }
            case DATAPROPERTYATOM: {
                a = DataPropertyAtom();
                break;
            }
            case BUILTINATOM: {
                a = BuiltInAtom();
                break;
            }
            case SAMEINDIVIDUALATOM: {
                a = SameIndividualAtom();
                break;
            }
            case DIFFERENTINDIVIDUALSATOM: {
                a = DifferentIndividualsAtom();
                break;
            }
            default:
                jj_la1[45] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return a;
    }

    final public SWRLClassAtom ClassAtom() throws ParseException {
        OWLClassExpression ce;
        SWRLIArgument arg0;
        jj_consume_token(CLASSATOM);
        jj_consume_token(OPENPAR);
        ce = ClassExpression();
        arg0 = IArg();
        jj_consume_token(CLOSEPAR);
        return df.getSWRLClassAtom(ce, arg0);
    }

    final public SWRLDataRangeAtom DataRangeAtom() throws ParseException {
        OWLDataRange rng;
        SWRLDArgument arg0;
        jj_consume_token(DATARANGEATOM);
        jj_consume_token(OPENPAR);
        rng = DataRange();
        arg0 = DArg();
        jj_consume_token(CLOSEPAR);
        return df.getSWRLDataRangeAtom(rng, arg0);
    }

    final public SWRLObjectPropertyAtom ObjectPropertyAtom() throws ParseException {
        OWLObjectPropertyExpression prop;
        SWRLIArgument arg0;
        SWRLIArgument arg1;
        jj_consume_token(OBJECTPROPERTYATOM);
        jj_consume_token(OPENPAR);
        prop = ObjectPropertyExpression();
        arg0 = IArg();
        arg1 = IArg();
        jj_consume_token(CLOSEPAR);
        return df.getSWRLObjectPropertyAtom(prop, arg0, arg1);
    }

    final public SWRLDataPropertyAtom DataPropertyAtom() throws ParseException {
        OWLDataProperty prop;
        SWRLIArgument arg0;
        SWRLDArgument arg1;
        jj_consume_token(DATAPROPERTYATOM);
        jj_consume_token(OPENPAR);
        prop = DataPropertyIRI();
        arg0 = IArg();
        arg1 = DArg();
        jj_consume_token(CLOSEPAR);
        return df.getSWRLDataPropertyAtom(prop, arg0, arg1);
    }

    final public SWRLBuiltInAtom BuiltInAtom() throws ParseException {
        IRI iri;
        List<SWRLDArgument> args;
        ;
        SWRLDArgument arg;
        jj_consume_token(BUILTINATOM);
        jj_consume_token(OPENPAR);
        args = new ArrayList<SWRLDArgument>();
        iri = IRI();
        arg = DArg();
        args.add(arg);
        label_20:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case STRINGLITERAL:
                case VARIABLE: {
                    ;
                    break;
                }
                default:
                    jj_la1[46] = jj_gen;
                    break label_20;
            }
            arg = DArg();
            args.add(arg);
        }
        jj_consume_token(CLOSEPAR);
        return df.getSWRLBuiltInAtom(iri, args);
    }

    final public SWRLSameIndividualAtom SameIndividualAtom() throws ParseException {
        SWRLIArgument arg0;
        SWRLIArgument arg1;
        jj_consume_token(SAMEINDIVIDUALATOM);
        jj_consume_token(OPENPAR);
        arg0 = IArg();
        arg1 = IArg();
        jj_consume_token(CLOSEPAR);
        return df.getSWRLSameIndividualAtom(arg0, arg1);
    }

    final public SWRLDifferentIndividualsAtom DifferentIndividualsAtom() throws ParseException {
        SWRLIArgument arg0;
        SWRLIArgument arg1;
        jj_consume_token(DIFFERENTINDIVIDUALSATOM);
        jj_consume_token(OPENPAR);
        arg0 = IArg();
        arg1 = IArg();
        jj_consume_token(CLOSEPAR);
        return df.getSWRLDifferentIndividualsAtom(arg0, arg1);
    }

    final public SWRLIArgument IArg() throws ParseException {
        OWLNamedIndividual ind;
        SWRLIArgument arg;
        IRI iri;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case VARIABLE: {
                jj_consume_token(VARIABLE);
                jj_consume_token(OPENPAR);
                iri = IRI();
                jj_consume_token(CLOSEPAR);
                arg = df.getSWRLVariable(iri);
                break;
            }
            case FULLIRI:
            case PNAME_LN: {
                ind = IndividualIRI();
                arg = df.getSWRLIndividualArgument(ind);
                break;
            }
            default:
                jj_la1[47] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return arg;
    }

    final public SWRLDArgument DArg() throws ParseException {
        SWRLDArgument arg;
        OWLLiteral literal;
        IRI iri;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case VARIABLE: {
                jj_consume_token(VARIABLE);
                jj_consume_token(OPENPAR);
                iri = IRI();
                jj_consume_token(CLOSEPAR);
                arg = df.getSWRLVariable(iri);
                break;
            }
            case STRINGLITERAL: {
                literal = Literal();
                arg = df.getSWRLLiteralArgument(literal);
                break;
            }
            default:
                jj_la1[48] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return arg;
    }

    /**
     * Generated Token Manager.
     */
    public OWLFunctionalSyntaxParserTokenManager token_source;
    SimpleCharStream jj_input_stream;
    /**
     * Current token.
     */
    public Token token;
    /**
     * Next token.
     */
    public Token jj_nt;
    private int jj_ntk;
    private int jj_gen;
    final private int[] jj_la1 = new int[49];
    static private int[] jj_la1_0;
    static private int[] jj_la1_1;
    static private int[] jj_la1_2;
    static private int[] jj_la1_3;
    static private int[] jj_la1_4;

    static {
        jj_la1_init_0();
        jj_la1_init_1();
        jj_la1_init_2();
        jj_la1_init_3();
        jj_la1_init_4();
    }

    private static void jj_la1_init_0() {
        jj_la1_0 = new int[]{0x0, 0x0, 0x0, 0x1010000, 0x1010000, 0xfce40000, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x800, 0x0, 0x0, 0x0, 0xfce40000, 0xe40000, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3c000000, 0x1000000, 0x0, 0x800, 0x1000000,
            0x0, 0x0, 0x2000000, 0x180000, 0x180000, 0x0, 0x0, 0x0, 0x800, 0x0, 0x800,};
    }

    private static void jj_la1_init_1() {
        jj_la1_1 = new int[]{0x0, 0x0, 0x0, 0x0, 0x0, 0x12000, 0x0, 0x7ffe0e00, 0x7ffe0e00, 0x0,
            0x7ffe0e00, 0x7ffe0e00, 0x7ffe0e00, 0xc1c0, 0xc1c0, 0xc1c0, 0x1000, 0xc1c0, 0x0, 0xc1c0,
            0xc1c0, 0x0, 0x12000, 0x0, 0x2000, 0x1000, 0x80001000, 0x1000, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x1000, 0x0, 0x3e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,};
    }

    private static void jj_la1_init_2() {
        jj_la1_2 = new int[]{0x2000000, 0x0, 0x0, 0x0, 0x0, 0x1ffffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1ffffff, 0x0, 0xfff, 0x0, 0x0, 0x0,
            0x3f000, 0x0, 0x1fc0000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0,};
    }

    private static void jj_la1_init_3() {
        jj_la1_3 = new int[]{0x0, 0x9000000, 0x9000000, 0x0, 0x0, 0x10, 0x9000000, 0x9000000,
            0x9000000, 0x9000000, 0x9000000, 0x9000000, 0x9000000, 0x9000000, 0x9000000, 0x9000000,
            0x9000000, 0x9000000, 0x0, 0x9000000, 0x9000000, 0x9000000, 0x10, 0x0, 0x0, 0x9000000,
            0x9000000, 0x9000000, 0x0, 0x9000000, 0x0, 0x9000000, 0x9000000, 0x0, 0x0, 0x9000000,
            0x9000000, 0x0, 0x9000000, 0x9000000, 0x0, 0x0, 0x0, 0x3f80, 0x3f80, 0x3f80, 0x4000,
            0x9004000, 0x4000,};
    }

    private static void jj_la1_init_4() {
        jj_la1_4 = new int[]{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x1, 0x1, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0,};
    }

    /**
     * Constructor.
     */
    public OWLFunctionalSyntaxParser(Provider stream) {
        jj_input_stream = new SimpleCharStream(stream, 1, 1);
        token_source = new OWLFunctionalSyntaxParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 49; i++) {
            jj_la1[i] = -1;
        }
    }

    /**
     * Constructor.
     */
    public OWLFunctionalSyntaxParser(String dsl) throws ParseException, TokenMgrException {
        this(new StringProvider(dsl));
    }

    public void ReInit(String s) {
        ReInit(new StringProvider(s));
    }

    /**
     * Reinitialise.
     */
    public void ReInit(Provider stream) {
        if (jj_input_stream == null) {
            jj_input_stream = new SimpleCharStream(stream, 1, 1);
        } else {
            jj_input_stream.ReInit(stream, 1, 1);
        }
        if (token_source == null) {
            token_source = new OWLFunctionalSyntaxParserTokenManager(jj_input_stream);
        }

        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 49; i++) {
            jj_la1[i] = -1;
        }
    }

    /**
     * Constructor with generated Token Manager.
     */
    public OWLFunctionalSyntaxParser(OWLFunctionalSyntaxParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 49; i++) {
            jj_la1[i] = -1;
        }
    }

    /**
     * Reinitialise.
     */
    public void ReInit(OWLFunctionalSyntaxParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 49; i++) {
            jj_la1[i] = -1;
        }
    }

    private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken;
        if ((oldToken = token).next != null) {
            token = token.next;
        } else {
            token = token.next = token_source.getNextToken();
        }
        jj_ntk = -1;
        if (token.kind == kind) {
            jj_gen++;
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }


    /**
     * Get the next Token.
     */
    final public Token getNextToken() {
        if (token.next != null) {
            token = token.next;
        } else {
            token = token.next = token_source.getNextToken();
        }
        jj_ntk = -1;
        jj_gen++;
        return token;
    }

    /**
     * Get the specific Token.
     */
    final public Token getToken(int index) {
        Token t = token;
        for (int i = 0; i < index; i++) {
            if (t.next != null) {
                t = t.next;
            } else {
                t = t.next = token_source.getNextToken();
            }
        }
        return t;
    }

    private int jj_ntk_f() {
        if ((jj_nt = token.next) == null) {
            return (jj_ntk = (token.next = token_source.getNextToken()).kind);
        } else {
            return (jj_ntk = jj_nt.kind);
        }
    }

    private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
    private int[] jj_expentry;
    private int jj_kind = -1;

    /**
     * Generate ParseException.
     */
    public ParseException generateParseException() {
        jj_expentries.clear();
        boolean[] la1tokens = new boolean[130];
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 49; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & (1 << j)) != 0) {
                        la1tokens[j] = true;
                    }
                    if ((jj_la1_1[i] & (1 << j)) != 0) {
                        la1tokens[32 + j] = true;
                    }
                    if ((jj_la1_2[i] & (1 << j)) != 0) {
                        la1tokens[64 + j] = true;
                    }
                    if ((jj_la1_3[i] & (1 << j)) != 0) {
                        la1tokens[96 + j] = true;
                    }
                    if ((jj_la1_4[i] & (1 << j)) != 0) {
                        la1tokens[128 + j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 130; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.add(jj_expentry);
            }
        }
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = jj_expentries.get(i);
        }
        return new ParseException(token, exptokseq, tokenImage, token_source == null ? null
            : OWLFunctionalSyntaxParserTokenManager.lexStateNames[token_source.curLexState]);
    }

    private int trace_indent = 0;
    private boolean trace_enabled;

    /**
     * Trace enabled.
     */
    final public boolean trace_enabled() {
        return trace_enabled;
    }

    /**
     * Enable tracing.
     */
    final public void enable_tracing() {
    }

    /**
     * Disable tracing.
     */
    final public void disable_tracing() {
    }

}

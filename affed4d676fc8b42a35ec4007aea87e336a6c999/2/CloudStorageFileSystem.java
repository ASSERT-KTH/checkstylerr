package com.google.gcloud.storage.contrib.nio;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;

import com.google.common.collect.ImmutableSet;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.file.FileStore;
import java.nio.file.FileSystem;
import java.nio.file.Path;
import java.nio.file.PathMatcher;
import java.nio.file.WatchService;
import java.nio.file.attribute.FileTime;
import java.nio.file.attribute.UserPrincipalLookupService;
import java.util.Objects;
import java.util.Set;

import javax.annotation.Nullable;
import javax.annotation.concurrent.Immutable;

/**
 * Google Cloud Storage {@link FileSystem}
 *
 * @see <a href="https://developers.google.com/storage/docs/concepts-techniques#concepts">
 *        Concepts and Terminology</a>
 * @see <a href="https://developers.google.com/storage/docs/bucketnaming">
 *        Bucket and Object Naming Guidelines</a>
 */
@Immutable
public final class CloudStorageFileSystem extends FileSystem {

  /**
   * Returns Google Cloud Storage {@link FileSystem} object for a given bucket name.
   *
   * <p><b>NOTE:</b> You may prefer to use Java's standard API instead:<pre>   {@code
   *
   *   FileSystem fs = FileSystems.getFileSystem(URI.create("gs://bucket"));}</pre>
   *
   * <p>However some systems and build environments might be flaky when it comes to Java SPI. This
   * is because services are generally runtime dependencies and depend on a META-INF file being
   * present in your jar (generated by Google Auto at compile-time). In such cases, this method
   * provides a simpler alternative.
   *
   * @see #forBucket(String, CloudStorageConfiguration)
   * @see java.nio.file.FileSystems#getFileSystem(java.net.URI)
   */
  public static CloudStorageFileSystem forBucket(String bucket) {
    return forBucket(bucket, CloudStorageConfiguration.DEFAULT);
  }

  /**
   * Creates a new filesystem for a particular bucket, with customizable settings.
   *
   * @see #forBucket(String)
   */
  public static CloudStorageFileSystem forBucket(String bucket, CloudStorageConfiguration config) {
    checkArgument(!bucket.startsWith(URI_SCHEME + ":"),
        "Bucket name must not have schema: %s", bucket);
    return new CloudStorageFileSystem(
        new CloudStorageFileSystemProvider(), bucket, checkNotNull(config));
  }

  public static final String URI_SCHEME = "gs";
  public static final String GCS_VIEW = "gcs";
  public static final String BASIC_VIEW = "basic";
  public static final int BLOCK_SIZE_DEFAULT = 2 * 1024 * 1024;
  public static final FileTime FILE_TIME_UNKNOWN = FileTime.fromMillis(0);
  public static final ImmutableSet<String> SUPPORTED_VIEWS = ImmutableSet.of(BASIC_VIEW, GCS_VIEW);

  private final CloudStorageFileSystemProvider provider;
  private final String bucket;
  private final CloudStorageConfiguration config;

  CloudStorageFileSystem(
      CloudStorageFileSystemProvider provider,
      String bucket,
      CloudStorageConfiguration config) {
    checkArgument(!bucket.isEmpty(), "bucket");
    this.provider = provider;
    this.bucket = bucket;
    this.config = config;
  }

  @Override
  public CloudStorageFileSystemProvider provider() {
    return provider;
  }

  /** Returns the Cloud Storage bucket name being served by this file system. */
  public String bucket() {
    return bucket;
  }

  /** Returns the configuration object for this filesystem instance. */
  public CloudStorageConfiguration config() {
    return config;
  }

  /** Converts a cloud storage object name to a {@link Path} object. */
  @Override
  public CloudStoragePath getPath(String first, String... more) {
    checkArgument(!first.startsWith(URI_SCHEME + ":"),
        "GCS FileSystem.getPath() must not have schema and bucket name: %s", first);
    return CloudStoragePath.getPath(this, first, more);
  }

  /** Does nothing. */
  @Override
  public void close() {}

  /** Returns {@code true} */
  @Override
  public boolean isOpen() {
    return true;
  }

  /** Returns {@code false} */
  @Override
  public boolean isReadOnly() {
    return false;
  }

  /** Returns {@value UnixPath#SEPARATOR} */
  @Override
  public String getSeparator() {
    return "" + UnixPath.SEPARATOR;
  }

  @Override
  public Iterable<Path> getRootDirectories() {
    return ImmutableSet.<Path>of(CloudStoragePath.getPath(this, UnixPath.ROOT));
  }

  @Override
  public Iterable<FileStore> getFileStores() {
    return ImmutableSet.of();
  }

  @Override
  public Set<String> supportedFileAttributeViews() {
    return SUPPORTED_VIEWS;
  }

  /** @throws UnsupportedOperationException */
  @Override
  public PathMatcher getPathMatcher(String syntaxAndPattern) {
    // TODO(b/18997520): Implement me.
    throw new UnsupportedOperationException();
  }

  /** @throws UnsupportedOperationException */
  @Override
  public UserPrincipalLookupService getUserPrincipalLookupService() {
    // TODO(b/18997520): Implement me.
    throw new UnsupportedOperationException();
  }

  /** @throws UnsupportedOperationException */
  @Override
  public WatchService newWatchService() throws IOException {
    // TODO(b/18997520): Implement me.
    throw new UnsupportedOperationException();
  }

  @Override
  public boolean equals(@Nullable Object other) {
    return this == other
        || other instanceof CloudStorageFileSystem
        && Objects.equals(config, ((CloudStorageFileSystem) other).config)
        && Objects.equals(bucket, ((CloudStorageFileSystem) other).bucket);
  }

  @Override
  public int hashCode() {
    return Objects.hash(bucket);
  }

  @Override
  public String toString() {
    try {
      return new URI(URI_SCHEME, bucket, null, null).toString();
    } catch (URISyntaxException e) {
      throw new AssertionError(e);
    }
  }
}

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.usergrid.persistence.model.util;


import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Random;
import java.util.UUID;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReentrantLock;

import com.fasterxml.uuid.EthernetAddress;
import com.fasterxml.uuid.TimestampSynchronizer;
import com.fasterxml.uuid.UUIDTimer;
import com.fasterxml.uuid.impl.TimeBasedGenerator;

import static com.fasterxml.uuid.impl.UUIDUtil.BYTE_OFFSET_CLOCK_HI;
import static com.fasterxml.uuid.impl.UUIDUtil.BYTE_OFFSET_CLOCK_LO;
import static com.fasterxml.uuid.impl.UUIDUtil.BYTE_OFFSET_CLOCK_MID;
import static com.fasterxml.uuid.impl.UUIDUtil.BYTE_OFFSET_CLOCK_SEQUENCE;


/**
 * TODO replace this with the existing usergridUUID utils, we seem to be getting inconsistent behavior from it
 */
public class UUIDGenerator {


    private static final int[] MICROS = new int[1000];


        static {
            for ( int x = 0; x < 1000; x++ ) {
                MICROS[x] = x * 10;
            }
        }


        private static ReentrantLock tsLock = new ReentrantLock( true );

        public static final UUID MIN_TIME_UUID = UUID.fromString( "00000000-0000-1000-8000-000000000000" );

        public static final UUID MAX_TIME_UUID = UUID.fromString( "ffffffff-ffff-1fff-bfff-ffffffffffff" );

        public static final UUID ZERO_UUID = new UUID( 0, 0 );

        private static long timestampMillisNow = System.currentTimeMillis();

        private static AtomicInteger currentMicrosPoint = new AtomicInteger( 0 );
        private static AtomicInteger customMicrosPointer = new AtomicInteger( 0 );


        /**
         * Return the "next" UUID in micro second resolution. <b>WARNING</b>: this is designed to return the next unique
         * timestamped UUID for this JVM. Depending on velocity of the call, this method may block internally to insure that
         * "now" is kept in sync with the UUIDs being generated by this call.
         * <p/>
         * In other words, we will intentionally burn CPU insuring that this method is not executed more than 10k -1 times
         * per millisecond and guarantee that those microseconds held within are sequential.
         * <p/>
         * If we did not do this, you would get <b>timestamp collision</b> even though the UUIDs will technically be
         * 'unique.'
         */
        public static UUID newTimeUUID() {
            // get & inc counter, but roll on 1k (because we divide by 10 on retrieval)
            // if count + currentMicro > 1k, block and roll
            tsLock.lock();
            long ts = System.currentTimeMillis();
            if ( ts > timestampMillisNow ) {
                timestampMillisNow = ts;
                currentMicrosPoint.set( 0 );
            }
            int pointer = currentMicrosPoint.getAndIncrement();
            try {
                if ( pointer > 990 ) {
                    TimeUnit.MILLISECONDS.sleep( 1L );
                }
            }
            catch ( Exception ex ) {
                ex.printStackTrace();
            }
            finally {
                tsLock.unlock();
            }
            return newTimeUUID( ts, MICROS[pointer] );
        }


        private static final long KCLOCK_OFFSET = 0x01b21dd213814000L;
        private static final long KCLOCK_MULTIPLIER_L = 10000L;

        private static final Random CLOCK_SEQ_RANDOM = new Random();


        // 14 bits of randomness
        private static int getRandomClockSequence() {
            return CLOCK_SEQ_RANDOM.nextInt() & 0x3FFF;
        }


        private static void setTimestamp( long timestamp, byte[] uuidBytes, int clockSeq, int timeOffset ) {

            timestamp *= KCLOCK_MULTIPLIER_L;
            timestamp += KCLOCK_OFFSET;
            timestamp += timeOffset;

            // Set random clock sequence
            uuidBytes[BYTE_OFFSET_CLOCK_SEQUENCE] = ( byte ) ( clockSeq >> 8 );
            uuidBytes[BYTE_OFFSET_CLOCK_SEQUENCE + 1] = ( byte ) clockSeq;

            // Set variant
            uuidBytes[BYTE_OFFSET_CLOCK_SEQUENCE] &= 0x3F;
            uuidBytes[BYTE_OFFSET_CLOCK_SEQUENCE] |= 0x80;
            setTime( uuidBytes, timestamp );
        }


        @SuppressWarnings("all")
        private static void setTime( byte[] uuidBytes, long timestamp ) {

            // Time fields aren't nicely split across the UUID, so can't just
            // linearly dump the stamp:
            int clockHi = ( int ) ( timestamp >>> 32 );
            int clockLo = ( int ) timestamp;

            uuidBytes[BYTE_OFFSET_CLOCK_HI] = ( byte ) ( clockHi >>> 24 );
            uuidBytes[BYTE_OFFSET_CLOCK_HI + 1] = ( byte ) ( clockHi >>> 16 );
            uuidBytes[BYTE_OFFSET_CLOCK_MID] = ( byte ) ( clockHi >>> 8 );
            uuidBytes[BYTE_OFFSET_CLOCK_MID + 1] = ( byte ) clockHi;

            uuidBytes[BYTE_OFFSET_CLOCK_LO] = ( byte ) ( clockLo >>> 24 );
            uuidBytes[BYTE_OFFSET_CLOCK_LO + 1] = ( byte ) ( clockLo >>> 16 );
            uuidBytes[BYTE_OFFSET_CLOCK_LO + 2] = ( byte ) ( clockLo >>> 8 );
            uuidBytes[BYTE_OFFSET_CLOCK_LO + 3] = ( byte ) clockLo;

            // Set version
            uuidBytes[BYTE_OFFSET_CLOCK_HI] &= 0x0F;
            uuidBytes[BYTE_OFFSET_CLOCK_HI] |= 0x10;
        }


        /**
         * Generate a timeuuid with the given timestamp in milliseconds and the time offset. Useful when you need to
         * generate sequential UUIDs for the same period in time. I.E
         * <p/>
         * newTimeUUID(1000, 0) <br/> newTimeUUID(1000, 1) <br /> newTimeUUID(1000, 2) <br />
         * <p/>
         * etc.
         * <p/>
         * Only use this method if you are absolutely sure you need it. When it doubt use the method without the timestamp
         * offset
         *
         * @param ts The timestamp in milliseconds
         * @param timeoffset The offset, which should always be <= 10000. If you go beyond this range, the millisecond will
         * be incremented since this is beyond the possible values when converting from millis to 1/10 microseconds stored
         * in the time uuid.
         */
        public static UUID newTimeUUID( long ts, int timeoffset ) {
            if ( ts == 0 ) {
                return newTimeUUID();
            }

            byte[] uuidBytes = new byte[16];
            // 47 bits of randomness
            EthernetAddress eth = EthernetAddress.constructMulticastAddress();
            eth.toByteArray( uuidBytes, 10 );
            setTimestamp( ts, uuidBytes, getRandomClockSequence(), timeoffset );

            return UUID.nameUUIDFromBytes( uuidBytes );
        }


        /**
         * Generate a new UUID with the given time stamp in milliseconds. This method guarantees that subsequent calls will
         * be of increasing value chronologically. If a large number of subsequent calls are made to this method (>1000)
         * with the same timestamp, you will have non-unique temporal values stored in your UUID.
         */
        public static UUID newTimeUUID( long ts ) {
            tsLock.lock();
            int pointer = customMicrosPointer.getAndIncrement();
            try {
                if ( pointer > 990 ) {
                    customMicrosPointer.set( 0 );
                }
            }
            finally {
                tsLock.unlock();
            }
            return newTimeUUID( ts, MICROS[pointer] );
        }


}
